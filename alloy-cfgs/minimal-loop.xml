<alloy builddate="2019-08-14T18:53:58.297Z">

<instance bitwidth="4" maxseq="4" command="Run run$1 for exactly 4 Block" filename="/Users/maxmitchell/Documents/individual-project/tools/cfg-paper-artifact/StructuredDominanceCFG.als">

<sig label="seq/Int" ID="0" parentID="1" builtin="yes">
</sig>

<sig label="Int" ID="1" parentID="2" builtin="yes">
</sig>

<sig label="String" ID="3" parentID="2" builtin="yes">
</sig>

<sig label="this/LoopHeader" ID="4" parentID="5">
   <atom label="LoopHeader$0"/>
</sig>

<field label="continue" ID="6" parentID="4">
   <tuple> <atom label="LoopHeader$0"/> <atom label="LoopHeader$0"/> </tuple>
   <types> <type ID="4"/> <type ID="7"/> </types>
</field>

<sig label="this/SelectionHeader" ID="8" parentID="5">
   <atom label="SelectionHeader$0"/>
</sig>

<sig label="this/HeaderBlock" ID="5" parentID="7">
</sig>

<field label="merge" ID="9" parentID="5">
   <tuple> <atom label="LoopHeader$0"/> <atom label="Block$1"/> </tuple>
   <tuple> <atom label="SelectionHeader$0"/> <atom label="LoopHeader$0"/> </tuple>
   <types> <type ID="5"/> <type ID="7"/> </types>
</field>

<sig label="this/Block" ID="7" parentID="2">
   <atom label="Block$0"/>
   <atom label="Block$1"/>
</sig>

<field label="branch" ID="10" parentID="7">
   <tuple> <atom label="LoopHeader$0"/> <atom label="0"/> <atom label="LoopHeader$0"/> </tuple>
   <tuple> <atom label="LoopHeader$0"/> <atom label="1"/> <atom label="Block$1"/> </tuple>
   <tuple> <atom label="SelectionHeader$0"/> <atom label="0"/> <atom label="LoopHeader$0"/> </tuple>
   <tuple> <atom label="SelectionHeader$0"/> <atom label="1"/> <atom label="Block$0"/> </tuple>
   <types> <type ID="7"/> <type ID="0"/> <type ID="7"/> </types>
</field>

<sig label="univ" ID="2" builtin="yes">
</sig>

<sig label="this/StructurallyReachableBlock" ID="11">
   <atom label="Block$0"/>
   <atom label="Block$1"/>
   <atom label="LoopHeader$0"/>
   <atom label="SelectionHeader$0"/>
   <type ID="7"/>
</sig>

<sig label="this/EntryBlock" ID="12" one="yes">
   <atom label="SelectionHeader$0"/>
   <type ID="7"/>
</sig>

<sig label="this/SwitchBlock" ID="13">
   <type ID="8"/>
</sig>

<skolem label="$this/branchSet" ID="m0">
   <tuple> <atom label="LoopHeader$0"/> <atom label="Block$1"/> </tuple>
   <tuple> <atom label="LoopHeader$0"/> <atom label="LoopHeader$0"/> </tuple>
   <tuple> <atom label="SelectionHeader$0"/> <atom label="Block$0"/> </tuple>
   <tuple> <atom label="SelectionHeader$0"/> <atom label="LoopHeader$0"/> </tuple>
   <types> <type ID="7"/> <type ID="7"/> </types>
</skolem>

<skolem label="$this/exitBlocks" ID="m1">
   <tuple> <atom label="Block$0"/> </tuple>
   <tuple> <atom label="Block$1"/> </tuple>
   <types> <type ID="7"/> </types>
</skolem>

<skolem label="$this/structurallyDominates" ID="m2">
   <tuple> <atom label="Block$0"/> <atom label="Block$0"/> </tuple>
   <tuple> <atom label="Block$1"/> <atom label="Block$1"/> </tuple>
   <tuple> <atom label="LoopHeader$0"/> <atom label="Block$1"/> </tuple>
   <tuple> <atom label="LoopHeader$0"/> <atom label="LoopHeader$0"/> </tuple>
   <tuple> <atom label="SelectionHeader$0"/> <atom label="Block$0"/> </tuple>
   <tuple> <atom label="SelectionHeader$0"/> <atom label="Block$1"/> </tuple>
   <tuple> <atom label="SelectionHeader$0"/> <atom label="LoopHeader$0"/> </tuple>
   <tuple> <atom label="SelectionHeader$0"/> <atom label="SelectionHeader$0"/> </tuple>
   <types> <type ID="7"/> <type ID="7"/> </types>
</skolem>

<skolem label="$this/strictlyStructurallyDominates" ID="m3">
   <tuple> <atom label="LoopHeader$0"/> <atom label="Block$1"/> </tuple>
   <tuple> <atom label="SelectionHeader$0"/> <atom label="Block$0"/> </tuple>
   <tuple> <atom label="SelectionHeader$0"/> <atom label="Block$1"/> </tuple>
   <tuple> <atom label="SelectionHeader$0"/> <atom label="LoopHeader$0"/> </tuple>
   <types> <type ID="7"/> <type ID="7"/> </types>
</skolem>

<skolem label="$this/structurallyPostDominates" ID="m4">
   <tuple> <atom label="Block$0"/> <atom label="Block$0"/> </tuple>
   <tuple> <atom label="Block$1"/> <atom label="Block$1"/> </tuple>
   <tuple> <atom label="Block$1"/> <atom label="LoopHeader$0"/> </tuple>
   <tuple> <atom label="LoopHeader$0"/> <atom label="LoopHeader$0"/> </tuple>
   <tuple> <atom label="SelectionHeader$0"/> <atom label="SelectionHeader$0"/> </tuple>
   <types> <type ID="7"/> <type ID="7"/> </types>
</skolem>

<skolem label="$this/backEdgeSeq" ID="m5">
   <tuple> <atom label="LoopHeader$0"/> <atom label="0"/> <atom label="LoopHeader$0"/> </tuple>
   <types> <type ID="7"/> <type ID="0"/> <type ID="7"/> </types>
</skolem>

<skolem label="$this/backEdge" ID="m6">
   <tuple> <atom label="LoopHeader$0"/> <atom label="LoopHeader$0"/> </tuple>
   <types> <type ID="7"/> <type ID="7"/> </types>
</skolem>

<skolem label="$this/contains" ID="m11">
   <tuple> <atom label="LoopHeader$0"/> <atom label="LoopHeader$0"/> </tuple>
   <tuple> <atom label="SelectionHeader$0"/> <atom label="Block$0"/> </tuple>
   <tuple> <atom label="SelectionHeader$0"/> <atom label="SelectionHeader$0"/> </tuple>
   <types> <type ID="7"/> <type ID="7"/> </types>
</skolem>

<skolem label="$this/exitEdge" ID="m12">
   <tuple> <atom label="LoopHeader$0"/> <atom label="Block$1"/> </tuple>
   <tuple> <atom label="SelectionHeader$0"/> <atom label="LoopHeader$0"/> </tuple>
   <types> <type ID="7"/> <type ID="7"/> </types>
</skolem>

</instance>

<source filename="/Users/maxmitchell/Documents/individual-project/tools/cfg-paper-artifact/StructuredDominanceCFG.als" content="/*&#x000a;     &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;  &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;  &#x2588;&#x2588;&#x2588;&#x2588;&#x2588; &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;              &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;   &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x000a;    &#x2588;&#x2588;&#x2588;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x2591;&#x2591;&#x2588;&#x2588;&#x2588; &#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2588;&#x2588;&#x2588;            &#x2591;&#x2591;&#x2588;&#x2588;&#x2588;   &#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x000a;   &#x2591;&#x2588;&#x2588;&#x2588;    &#x2591;&#x2591;&#x2591;  &#x2591;&#x2588;&#x2588;&#x2588;    &#x2591;&#x2588;&#x2588;&#x2588; &#x2591;&#x2588;&#x2588;&#x2588;  &#x2591;&#x2588;&#x2588;&#x2588;    &#x2591;&#x2588;&#x2588;&#x2588;             &#x2591;&#x2588;&#x2588;&#x2588;    &#x2591;&#x2588;&#x2588;&#x2588;&#x000a;   &#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;  &#x2591;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;  &#x2591;&#x2588;&#x2588;&#x2588;  &#x2591;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;   &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588; &#x2591;&#x2588;&#x2588;&#x2588;    &#x2591;&#x2588;&#x2588;&#x2588;&#x000a;    &#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2588;&#x2588;&#x2588; &#x2591;&#x2588;&#x2588;&#x2588;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;   &#x2591;&#x2588;&#x2588;&#x2588;  &#x2591;&#x2588;&#x2588;&#x2588;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2588;&#x2588;&#x2588; &#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;  &#x2591;&#x2591;&#x2588;&#x2588;&#x2588;   &#x2588;&#x2588;&#x2588;&#x000a;    &#x2588;&#x2588;&#x2588;    &#x2591;&#x2588;&#x2588;&#x2588; &#x2591;&#x2588;&#x2588;&#x2588;         &#x2591;&#x2588;&#x2588;&#x2588;  &#x2591;&#x2588;&#x2588;&#x2588;    &#x2591;&#x2588;&#x2588;&#x2588;              &#x2591;&#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2591;&#x000a;   &#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;  &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;        &#x2588;&#x2588;&#x2588;&#x2588;&#x2588; &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;   &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;               &#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x000a;    &#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;  &#x2591;&#x2591;&#x2591;&#x2591;&#x2591;        &#x2591;&#x2591;&#x2591;&#x2591;&#x2591; &#x2591;&#x2591;&#x2591;&#x2591;&#x2591;   &#x2591;&#x2591;&#x2591;&#x2591;&#x2591;                 &#x2591;&#x2591;&#x2591;&#x000a;&#x000a;&#x000a;  &#x250c;&#x2500;&#x2510;&#x252c;  &#x252c;    &#x250c;&#x2500;&#x2510;&#x252c; &#x252c;&#x250c;&#x2510;&#x250c;&#x250c;&#x2500;&#x2510;&#x250c;&#x252c;&#x2510;&#x252c;&#x250c;&#x2500;&#x2510;&#x250c;&#x2510;&#x250c;&apos;&#x250c;&#x2500;&#x2510;  &#x252c;  &#x250c;&#x2500;&#x2510;&#x250c;&#x2500;&#x2510;&#x250c;&#x2500;&#x2510;&#x250c;&#x2500;&#x2510;  &#x250c;&#x2500;&#x2510;&#x252c;&#x2500;&#x2510;&#x250c;&#x2500;&#x2510;  &#x250c;&#x2500;&#x2510;&#x250c;&#x252c;&#x2510;&#x252c;&#x2500;&#x2510;&#x252c; &#x252c;&#x250c;&#x2500;&#x2510;&#x250c;&#x252c;&#x2510;&#x252c; &#x252c;&#x252c;&#x2500;&#x2510;&#x250c;&#x2500;&#x2510;&#x250c;&#x252c;&#x2510;&#x000a;  &#x251c;&#x2500;&#x2524;&#x2502;  &#x2502;    &#x251c;&#x2524; &#x2502; &#x2502;&#x2502;&#x2502;&#x2502;&#x2502;   &#x2502; &#x2502;&#x2502; &#x2502;&#x2502;&#x2502;&#x2502; &#x2514;&#x2500;&#x2510;  &#x2502;  &#x2502; &#x2502;&#x2502; &#x2502;&#x251c;&#x2500;&#x2518;&#x2514;&#x2500;&#x2510;  &#x251c;&#x2500;&#x2524;&#x251c;&#x252c;&#x2518;&#x251c;&#x2524;   &#x2514;&#x2500;&#x2510; &#x2502; &#x251c;&#x252c;&#x2518;&#x2502; &#x2502;&#x2502;   &#x2502; &#x2502; &#x2502;&#x251c;&#x252c;&#x2518;&#x251c;&#x2524;  &#x2502;&#x2502;&#x000a;  &#x2534; &#x2534;&#x2534;&#x2500;&#x2518;&#x2534;&#x2500;&#x2518;  &#x2514;  &#x2514;&#x2500;&#x2518;&#x2518;&#x2514;&#x2518;&#x2514;&#x2500;&#x2518; &#x2534; &#x2534;&#x2514;&#x2500;&#x2518;&#x2518;&#x2514;&#x2518; &#x2514;&#x2500;&#x2518;  &#x2534;&#x2500;&#x2518;&#x2514;&#x2500;&#x2518;&#x2514;&#x2500;&#x2518;&#x2534;  &#x2514;&#x2500;&#x2518;  &#x2534; &#x2534;&#x2534;&#x2514;&#x2500;&#x2514;&#x2500;&#x2518;  &#x2514;&#x2500;&#x2518; &#x2534; &#x2534;&#x2514;&#x2500;&#x2514;&#x2500;&#x2518;&#x2514;&#x2500;&#x2518; &#x2534; &#x2514;&#x2500;&#x2518;&#x2534;&#x2514;&#x2500;&#x2514;&#x2500;&#x2518;&#x2500;&#x2534;&#x2518;&#x000a;&#x000a;&#x0009;&#x2013; Loops must be structured, having an OpLoopMerge instruction in their header.&#x000a;&#x0009;&#x2013; Selections must be structured, having an OpSelectionMerge instruction in their header.&#x000a; */&#x000a;&#x000a;&#x000a;&#x000a;&#x000a;         /* &#x000a;&#x0009;&#x0009;&#x0009; * This version allows but ignores structurally-unreachable blocks which means that &#x000a;&#x0009;&#x0009;&#x0009; * structurally control flow rules do not apply to &quot;wholly unreachable&quot; blocks.&#x000a;&#x0009;&#x0009;&#x0009; * For this, we define  StructurallyReachableBlock (as a subset of Block) which contains only&#x000a;&#x0009;&#x0009;&#x0009; * structurally reachable blocks which obey the structurally control flow rules&#x000a;&#x0009;&#x0009;&#x0009; */&#x000a;&#x000a;&#x000a;&#x000a;&#x000a;&#x000a;open util/relation&#x000a;//open util/ordering[State] as ord&#x000a;&#x000a;&#x000a;module StructuredDominanceCFG&#x000a;&#x000a;&#x000a;sig Block   &#x000a;{&#x000a;&#x0009;branch: seq Block&#x000a;}&#x000a;&#x000a;&#x000a;sig  StructurallyReachableBlock  in Block  {} &#x000a;&#x000a;&#x000a;let StructurallyUnreachableBlock =  Block -  StructurallyReachableBlock  &#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;Entry Point: A function in a module where execution begins&quot;&#x000a;  *  (The Khronos Group, 2021, p.19)&#x000a;  *  https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  */&#x000a;one sig EntryBlock in  Block  {}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;Header Block: A block containing a merge instruction&quot;&#x000a;  *  (The Khronos Group, 2021, p.20)&#x000a;  *  https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  */&#x000a;sig HeaderBlock extends  Block    &#x000a;{&#x000a;&#x0009;merge : one  Block &#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;Loop Header: A header block whose merge instruction is an OpLoopMerge&quot;&#x000a;  *  (The Khronos Group, 2021, p.20)&#x000a;  *  https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  */&#x000a;sig LoopHeader extends HeaderBlock   &#x000a;{&#x000a;&#x0009;continue : one  Block &#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;Selections must be structured, having an OpSelectionMerge instruction in their header&quot;&#x000a;  *  (The Khronos Group, 2021, p.37)&#x000a;  *  https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  *&#x000a;  */&#x000a;sig SelectionHeader extends HeaderBlock {}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  An OpSwitch block (which contains a multi-way branch instruction) must have, at a minimum,&#x000a;  *  a successor for the &quot;default&quot; case&#x000a;  */&#x000a;sig SwitchBlock in SelectionHeader  {}&#x000a;{&#x000a;&#x0009;some branch&#x000a;}&#x000a;&#x000a;&#x000a;&#x000a;&#x000a;&#x000a;&#x000a;/*&#x000a;       &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;                                  &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;     &#x2588;&#x2588;&#x2588;&#x000a;      &#x2588;&#x2588;&#x2588;&#x2591;&#x2591;&#x2588;&#x2588;&#x2588;                                &#x2591;&#x2591;&#x2588;&#x2588;&#x2588;     &#x2591;&#x2591;&#x2591;&#x000a;     &#x2591;&#x2588;&#x2588;&#x2588; &#x2591;&#x2591;&#x2591;  &#x2588;&#x2588;&#x2588;&#x2588;&#x2588; &#x2588;&#x2588;&#x2588;&#x2588; &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;    &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;  &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;   &#x2588;&#x2588;&#x2588;&#x2588;   &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;  &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;    &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x000a;    &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;   &#x2591;&#x2591;&#x2588;&#x2588;&#x2588; &#x2591;&#x2588;&#x2588;&#x2588; &#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x2591;&#x2591;&#x2588;&#x2588;&#x2588;  &#x2588;&#x2588;&#x2588;&#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x2591;&#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x2591;   &#x2591;&#x2591;&#x2588;&#x2588;&#x2588;  &#x2588;&#x2588;&#x2588;&#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x2591;&#x2591;&#x2588;&#x2588;&#x2588;  &#x2588;&#x2588;&#x2588;&#x2591;&#x2591;&#x000a;   &#x2591;&#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x2591;     &#x2591;&#x2588;&#x2588;&#x2588; &#x2591;&#x2588;&#x2588;&#x2588;  &#x2591;&#x2588;&#x2588;&#x2588; &#x2591;&#x2588;&#x2588;&#x2588; &#x2591;&#x2588;&#x2588;&#x2588; &#x2591;&#x2591;&#x2591;   &#x2591;&#x2588;&#x2588;&#x2588;     &#x2591;&#x2588;&#x2588;&#x2588; &#x2591;&#x2588;&#x2588;&#x2588; &#x2591;&#x2588;&#x2588;&#x2588; &#x2591;&#x2588;&#x2588;&#x2588; &#x2591;&#x2588;&#x2588;&#x2588; &#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x000a;     &#x2591;&#x2588;&#x2588;&#x2588;      &#x2591;&#x2588;&#x2588;&#x2588; &#x2591;&#x2588;&#x2588;&#x2588;  &#x2591;&#x2588;&#x2588;&#x2588; &#x2591;&#x2588;&#x2588;&#x2588; &#x2591;&#x2588;&#x2588;&#x2588;  &#x2588;&#x2588;&#x2588;  &#x2591;&#x2588;&#x2588;&#x2588; &#x2588;&#x2588;&#x2588; &#x2591;&#x2588;&#x2588;&#x2588; &#x2591;&#x2588;&#x2588;&#x2588; &#x2591;&#x2588;&#x2588;&#x2588; &#x2591;&#x2588;&#x2588;&#x2588; &#x2591;&#x2588;&#x2588;&#x2588;  &#x2591;&#x2591;&#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x000a;     &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;     &#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588; &#x2588;&#x2588;&#x2588;&#x2588; &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;   &#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;  &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;  &#x2588;&#x2588;&#x2588;&#x2588; &#x2588;&#x2588;&#x2588;&#x2588;&#x2588; &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x000a;    &#x2591;&#x2591;&#x2591;&#x2591;&#x2591;       &#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591; &#x2591;&#x2591;&#x2591;&#x2591; &#x2591;&#x2591;&#x2591;&#x2591;&#x2591;  &#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;     &#x2591;&#x2591;&#x2591;&#x2591;&#x2591;  &#x2591;&#x2591;&#x2591;&#x2591;&#x2591;  &#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;  &#x2591;&#x2591;&#x2591;&#x2591; &#x2591;&#x2591;&#x2591;&#x2591;&#x2591; &#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x000a;&#x000a; */&#x000a;&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &apos;branchSet&apos; maps to the (unordered) set of elements in sequence &quot;branch&quot;&#x000a;  */&#x000a;fun branchSet :  Block -&gt; Block &#x000a;{&#x000a;    { A, B: Block | B in ((A.branch).elems) }&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  exitBlocks models the set of &quot;Termination Instruction&quot; used to terminate blocks&#x000a;  *  (The Khronos Group, 2021, p.20)&#x000a;  *  https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  */&#x000a;fun exitBlocks :  Block    &#x000a;{&#x000a;&#x0009;{ B:  Block  | no B&lt;:branch}&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  A helper function for the computation of structured-(post)-dominance relation&#x000a;  */&#x000a;fun MetaReachableFromWithoutPassingThrough[from,through:  StructurallyReachableBlock ] : set  Block  &#x000a;{&#x000a;&#x0009;from.*(( StructurallyReachableBlock -through) &lt;: (branchSet + merge + continue) ) - through&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  An augmented notion of dominance:&#x000a;  *  &apos;A&apos; structurally-dominates &apos;B&apos; if every path made up of &apos;branch&apos;, &apos;merge&apos; and &apos;continue&apos;&#x000a;  *  edges from the function&#x2019;s entry point to block &apos;B&apos; includes block &apos;A&apos;.&#x000a;&#x000a;&#x0009;&#x0009; Entry&#x000a;&#x0009;       &#x2b07;&#x000a;&#x0009;&#x0009;&#x0009;  A&#x000a;&#x0009;&#x0009;     &#x2b07;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;B&#x000a;  */&#x000a;fun structurallyDominates :   Block  -&gt;  Block  &#x000a;{&#x000a;&#x0009;{ A, B:  StructurallyReachableBlock   |  B in A.*(branchSet + merge + continue) and B not in MetaReachableFromWithoutPassingThrough[EntryBlock,A] }&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;&apos;A&apos; strictly structurally-dominates &apos;B&apos; only if &apos;A&apos; structurally-dominates &apos;B&apos;&#x000a;  *   and &apos;A&apos; and &apos;B&apos; are different blocks&quot;&#x000a;  */&#x000a;fun strictlyStructurallyDominates :  Block  -&gt;  Block &#x000a;{&#x000a;&#x0009;structurallyDominates - iden&#x000a;}&#x000a;&#x000a;&#x000a;&#x000a;/**&#x000a;  *  An augmented notion of post-dominance:&#x000a;  *  &apos;B&apos; structurally-post-dominates &apos;A&apos; if every path made up of &apos;branch&apos;, &apos;merge&apos; and &apos;continue&apos;&#x000a;  *  edges from &apos;A&apos; to a function-return instruction goes through block &apos;B&apos;.&#x000a;&#x000a;&#x0009;&#x0009;    A&#x000a;&#x0009;       &#x2b07;&#x000a;&#x0009;&#x0009;&#x0009;  B&#x000a;&#x0009;&#x0009;     &#x2b07;&#x000a;&#x0009;&#x0009;&#x0009;  Exit&#x000a;  */&#x000a;fun structurallyPostDominates :   Block  -&gt;  Block  &#x000a;{&#x000a;    { B, A:  Block  | B in A.*(branchSet + merge + continue) and no exitBlocks &amp; MetaReachableFromWithoutPassingThrough[A,B] }&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;A back edge is an edge D -&gt; B whose head B structurally-dominates its tail D&quot;&#x000a;  *&#x000a;  *   The definition given in the SPIR-V spec..&#x000a;  *&#x000a;  *&#x0009;(The Khronos Group, 2021, p.20)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  */&#x000a;fun backEdgeSeq :  branch &#x000a;{&#x000a;&#x0009;-- We take into account all parallel back edges (incident to the same pair)&#x000a;&#x0009;{ &#x0009; &#x000a;&#x0009;&#x0009;D:  Block  , i:Int, B:  Block  |  B-&gt;D in structurallyDominates and &#x0009; B in D.branchSet and i &gt;=0 and i &lt; #(D.(branch:&gt;B))&#x000a;&#x0009;}&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &apos;backEdge&apos; maps to the (unordered) set of elements in sequence &quot;backEdgeSeq&quot;&#x000a;  */&#x000a;fun backEdge :   Block  -&gt;  Block  &#x000a;{&#x000a;    { A, B:  Block  | B in ((A.backEdgeSeq).elems) }&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;A selection construct: includes the blocks dominated by a selection header,&#x000a;  *   while excluding blocks dominated by the selection construct&#x2019;s merge block.&#x000a;  *&#x000a;  *   (The Khronos Group, 2021, p.29)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  */&#x000a;fun selectionConstruct [sh: SelectionHeader] :  StructurallyReachableBlock    &#x000a;{&#x000a;&#x0009;(sh&amp;SelectionHeader).structurallyDominates - (sh&amp;SelectionHeader).merge.structurallyDominates&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;A continue construct: includes the blocks dominated by an OpLoopMerge Continue Target&#x000a;  *   and post dominated by the corresponding loop&#x2019;s back-edge block, while excluding blocks&#x000a;  *   dominated by that loop&#x2019;s merge block.&#x000a;  *&#x000a;  *   (The Khronos Group, 2021, p.29)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  *&#x000a;  *&#x0009;Defining the continue construct to be the blocks structurally dominated by the continue &#x000a;  *&#x0009;target and structurally post-dominated by the back-edge block should give a &#x000a;  *&#x0009;single-entry-single-exit region of blocks, and surely this cannot include any blocks &#x000a;  *&#x0009;structurally dominated by the loop&apos;s merge block, so that we&apos;re removing an empty set&#x000a;  */&#x000a;fun continueConstruct [ct: LoopHeader.continue] :  StructurallyReachableBlock    &#x000a;{&#x000a;&#x0009;(  ((ct&amp;(LoopHeader.continue)).structurallyDominates) &amp; (((ct&amp;(LoopHeader.continue)).~continue.~backEdge).structurallyPostDominates) ) &#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;A loop construct: includes the blocks dominated by a loop header, while excluding both&#x000a;  *   that header&#x2019;s continue construct and the blocks dominated by the loop&#x2019;s merge block&#x000a;  *&#x000a;  *   (The Khronos Group, 2021, p.29)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  */&#x000a;fun loopConstruct [lh: LoopHeader] :  StructurallyReachableBlock    &#x000a;{&#x000a;&#x0009;(lh&amp;LoopHeader).structurallyDominates - continueConstruct[(lh&amp;LoopHeader).continue] - (lh&amp;LoopHeader).merge.structurallyDominates&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;A case construct: the blocks dominated by an OpSwitch Target or Default (this construct&#x000a;  *   is only defined for those OpSwitch Target or Default that are not equal to the OpSwitch&#x2019;s&#x000a;  *   corresponding merge block)&#x000a;  *&#x000a;  *   (The Khronos Group, 2021, p.29)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  *&#x000a;  *&#x000a;  *   Changes to definition above:&#x000a;  *   &#x201c;a case construct: the blocks structurally dominated by an OpSwitch Target or Default, &#x000a;  *    excluding the blocks structurally dominated by the OpSwitch&#x2019;s corresponding merge block &#x000a;  *   (this construct is only defined for those OpSwitch Target or Default that are not equal &#x000a;  *    to the OpSwitch&#x2019;s corresponding merge block)&#x201d;&#x000a;  */&#x000a;fun caseConstruct [t:  StructurallyReachableBlock ] :  StructurallyReachableBlock  &#x000a;{&#x000a;  { b:  StructurallyReachableBlock  | let sw = t.~branchSet &amp; SwitchBlock  |&#x000a;              &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;    ( some sw&#x0009;     &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;    ) &#x000a;            &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;  and  (sw.merge != t &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;    ) &#x000a;             &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;  and  (t -&gt; b in structurallyDominates )&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;  and  (sw.merge-&gt;b not in structurallyDominates)&#x000a;  }&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  A nested loop is a loop within a loop; an inner loop within the body of an outer one.&#x000a;  */&#x000a;fun outerInnerLoop  :  StructurallyReachableBlock  -&gt;  StructurallyReachableBlock  &#x000a;{&#x000a;  {&#x000a;&#x0009;   disj outH, inH: LoopHeader | inH in loopConstruct[outH]&#x000a;  }&#x000a;}&#x000a;&#x000a;&#x000a;fun outerInner  : Block -&gt; Block {&#x000a;&#x0009;{&#x000a;&#x0009;&#x0009;disj outer, inner: constructHeader | inner in  selectionConstruct[outer] + &#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; &#x0009;&#x0009;&#x0009;  loopConstruct[outer]      +&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; &#x0009;&#x0009;&#x0009;  continueConstruct[outer]  +&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;  caseConstruct[outer]      &#x000a;&#x0009;}&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  returns the innermost loop a block (b) is nested inside of&#x000a;  */&#x000a;fun innermostLoop[b:   StructurallyReachableBlock ] : lone  StructurallyReachableBlock    &#x000a;{&#x000a;&#x0009;{&#x000a;&#x0009;&#x0009; h: LoopHeader | (  b in loopConstruct[h] ) and (  b not in loopConstruct[h.outerInnerLoop]   )&#x000a;   }&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  A nested continue construct is one within another;&#x000a;  */&#x000a;fun outerInnerContinue  :  StructurallyReachableBlock  -&gt;  StructurallyReachableBlock  &#x000a;{&#x000a;  {&#x000a;&#x0009;   disj outer, inner: LoopHeader.continue | inner in continueConstruct[outer]&#x000a;  }&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  returns the innermost continue construct a block (b) is nested inside of&#x000a;  */&#x000a;fun innermostContinue[b:   StructurallyReachableBlock ] : lone  StructurallyReachableBlock    &#x000a;{&#x000a;&#x0009;{&#x000a;&#x0009;&#x0009; c: LoopHeader.continue | (  b in continueConstruct[c] ) and (  b not in continueConstruct[c.outerInnerContinue]   )&#x000a;   }&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  A nested Switch is a switch within a switch; an inner switch within the body of an outer one.&#x000a;  */&#x000a;fun outerInnerSW  :  StructurallyReachableBlock  -&gt;  StructurallyReachableBlock  {&#x000a;&#x0009;{&#x000a;&#x0009;&#x0009;disj outSW, inSW: SwitchBlock | inSW in selectionConstruct[outSW]&#x000a;&#x0009;}&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  returns the innermost OpSwitch a block (b) is nested inside of&#x000a;  */&#x000a;fun innermostOpSwitch[b:  StructurallyReachableBlock ] : lone  StructurallyReachableBlock    {&#x000a;&#x0009;{ &#x000a;&#x0009;&#x0009;sw: SwitchBlock |  ( &#x0009;b in selectionConstruct[sw] )&#x0009;and ( some sw.outerInnerSW =&gt; b not in selectionConstruct[sw.outerInnerSW] &#x0009;)&#x000a;&#x0009;}&#x000a;}&#x000a;&#x000a;&#x000a;let constructHeader =  HeaderBlock + LoopHeader.continue + (SwitchBlock.branchSet - SwitchBlock.merge)  &#x000a;&#x000a;&#x000a;fun contains :  StructurallyReachableBlock  -&gt;  StructurallyReachableBlock  {&#x000a;&#x0009;{&#x000a;&#x0009; outer, inner:  StructurallyReachableBlock  &#x000a;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; | let lCouter = loopConstruct[outer]&#x0009;&#x0009;, lCinner = loopConstruct[inner], &#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; sCouter = selectionConstruct[outer], sCinner = selectionConstruct[inner] ,&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; ctCouter = continueConstruct[outer], ctCinner = continueConstruct[inner] ,&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; csCouter = caseConstruct[outer] &#x0009;, csCinner = caseConstruct[inner],&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; case =  SwitchBlock.branchSet - SwitchBlock.merge&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; &#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; |&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(outer in LoopHeader and inner in LoopHeader&#x0009;&#x0009; &#x0009; &#x0009;and some lCinner  and some lCouter and lCinner  in lCouter ) or&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(outer in LoopHeader and inner in SelectionHeader &#x0009;&#x0009;and some sCinner  and some lCouter and sCinner  in lCouter ) or&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(outer in LoopHeader and inner in LoopHeader.continue and some ctCinner and some lCouter and ctCinner in lCouter ) or&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(outer in LoopHeader and inner in case&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; &#x0009;and some csCinner and some lCouter and csCinner in lCouter ) or&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(outer in SelectionHeader and inner in LoopHeader&#x0009;&#x0009; &#x0009;  and some lCinner  and some sCouter and lCinner  in sCouter ) or&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(outer in SelectionHeader and inner in SelectionHeader &#x0009;  and some sCinner  and some sCouter and sCinner  in sCouter ) or&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(outer in SelectionHeader and inner in LoopHeader.continue and some ctCinner and some sCouter and ctCinner in sCouter ) or&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(outer in SelectionHeader and inner in case&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;  and some csCinner and some sCouter and csCinner in sCouter ) or&#x000a;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(outer in LoopHeader.continue and inner in LoopHeader&#x0009;&#x0009; &#x0009;   and some lCinner  and some ctCouter and lCinner  in ctCouter ) or&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(outer in LoopHeader.continue and inner in SelectionHeader &#x0009;   and some sCinner  and some ctCouter and sCinner  in ctCouter ) or&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(outer in LoopHeader.continue and inner in LoopHeader.continue and some ctCinner and some ctCouter and ctCinner in ctCouter ) or&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(outer in LoopHeader.continue and inner in case&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;   and some csCinner and some ctCouter and csCinner in ctCouter ) or&#x000a;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(outer in SwitchBlock.branchSet and inner in LoopHeader&#x0009;&#x0009; &#x0009;   and some lCinner  and some csCouter and lCinner  in csCouter ) or&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(outer in SwitchBlock.branchSet and inner in SelectionHeader &#x0009;   and some sCinner  and some csCouter and sCinner  in csCouter ) or&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(outer in SwitchBlock.branchSet and inner in LoopHeader.continue and some ctCinner and some csCouter and ctCinner in csCouter ) or&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(outer in SwitchBlock.branchSet and inner in case&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;and some csCinner and some csCouter and csCinner in csCouter ) or&#x000a;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(outer in LoopHeader &#x0009;&#x0009;&#x0009;and inner not in constructHeader&#x0009;and inner in lCouter )  or&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(outer in SelectionHeader &#x0009;&#x0009;and inner not in constructHeader and inner in sCouter )  or &#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(outer in LoopHeader.continue and inner not in constructHeader and inner in ctCouter)  or&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(outer in SwitchBlock.branchSet and inner not in constructHeader and inner in csCouter) &#x000a;&#x0009;}&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *&#x0009;Innermost T construct containing a block: Let T be one of &#x201c;loop&#x201d;, &#x201c;continue&#x201d;, &#x201c;selection&#x201d;.&#x000a;  *&#x0009;Let B be a structurally-reachable block in the control flow graph of a function. &#x000a;  *&#x0009;If B is not contained in any T construct, then the innermost T construct containing B is undefined. &#x000a;  *&#x0009;Otherwise, let C be the unique T construct such that:&#x000a;  *&#x0009;- C contains B;&#x000a;  *&#x0009;- Every T construct that contains B also contains C.&#x000a;  *&#x0009;The T construct C is the innermost T construct containing B.&#x000a;  */&#x000a;fun innermostConstructHeader[B:  StructurallyReachableBlock ] :  StructurallyReachableBlock    {&#x000a;&#x0009;{ &#x000a;&#x0009;&#x0009;C: constructHeader | &#x0009;(&#x0009;B in C.contains) and &#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;B not in ((C.contains) &amp; (constructHeader -C)).contains&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; )&#x000a;&#x0009;}&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *&#x0009;It could be the case that a block has more than one instance, e.g., loop header and continue target &#x000a;  *&#x000a;  *&#x0009;let C-&gt;D; given a construct header C, if D not in the biggest construct than by computing the smallest construct &#x000a;  *&#x0009;we capture all exits, from smallest and biggest too&#x000a;  */&#x000a;fun innermostConstr[B:  StructurallyReachableBlock ] : set  StructurallyReachableBlock    {&#x000a;&#x0009;{ &#x000a;&#x0009;  C:  StructurallyReachableBlock  | let inH = innermostConstructHeader[B],&#x0009;&#x0009;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;lC = loopConstruct[inH]&#x0009;&#x0009;, &#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;sC = selectionConstruct[inH], &#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;ctC= continueConstruct[inH], &#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;csC= caseConstruct[inH] &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; &#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;| &#x0009;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(B in lC =&gt; C in lC)   and&#x0009;&#x0009;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(B in sC =&gt; C in sC)   and&#x0009;&#x0009;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(B in ctC =&gt; C in ctC) and&#x0009;&#x0009;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(B in csC =&gt; C in csC) &#x0009;&#x0009;&#x000a;&#x0009; &#x0009;&#x000a;&#x0009;}&#x000a;}&#x000a;&#x000a;&#x000a;fun exitEdge :  StructurallyReachableBlock  -&gt;  StructurallyReachableBlock  {&#x000a;    { B, C:  StructurallyReachableBlock  &#x000a;&#x0009;&#x0009; | &#x000a;&#x0009;&#x0009;&#x0009; let headOfInnermostConst_B = innermostConstructHeader[B], &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;   &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;   &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;   &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;  innermostConstruct_B &#x0009; = innermostConstr[B]&#x0009;&#x000a;&#x0009;&#x0009; |&#x0009;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;C in B.branchSet and some headOfInnermostConst_B and C not in innermostConstruct_B&#x000a;&#x0009;} &#x000a;}&#x000a;&#x000a;&#x000a;&#x000a;&#x000a;&#x000a;/*&#x000a;&#x000a;    &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;                     &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x000a;   &#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2588;                    &#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x000a;    &#x2591;&#x2588;&#x2588;&#x2588;   &#x2588; &#x2591;   &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;    &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;  &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;    &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x000a;    &#x2591;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;    &#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2588;&#x2588;&#x2588;  &#x2588;&#x2588;&#x2588;&#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x2591;&#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x2591;    &#x2588;&#x2588;&#x2588;&#x2591;&#x2591;&#x000a;    &#x2591;&#x2588;&#x2588;&#x2588;&#x2591;&#x2591;&#x2591;&#x2588;     &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588; &#x2591;&#x2588;&#x2588;&#x2588; &#x2591;&#x2591;&#x2591;   &#x2591;&#x2588;&#x2588;&#x2588;    &#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x000a;    &#x2591;&#x2588;&#x2588;&#x2588;  &#x2591;     &#x2588;&#x2588;&#x2588;&#x2591;&#x2591;&#x2588;&#x2588;&#x2588; &#x2591;&#x2588;&#x2588;&#x2588;  &#x2588;&#x2588;&#x2588;  &#x2591;&#x2588;&#x2588;&#x2588; &#x2588;&#x2588;&#x2588; &#x2591;&#x2591;&#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x000a;    &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;      &#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;   &#x2591;&#x2591;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;  &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x000a;   &#x2591;&#x2591;&#x2591;&#x2591;&#x2591;        &#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;  &#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;     &#x2591;&#x2591;&#x2591;&#x2591;&#x2591;  &#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x000a;&#x000a; */&#x000a;&#x000a;&#x000a;&#x000a;/**&#x000a;  *   &apos;StructurallyReachableBlock&apos; is structurally-reachable from Entry&#x000a;  */&#x000a;fact &#x000a;{&#x000a;&#x0009;StructurallyReachableBlock  = EntryBlock.*(branchSet + merge + continue)&#x000a;}&#x000a;&#x000a;&#x000a;/** This fact tells explicitly that merge and continues for a loop must be different.&#x000a;&#x0009; In the spec, this fact is implicit comming from the condition (that otherwise is redundant)&#x000a;    that &quot;a continue construct must contain its loop&apos;s back edge block&quot;.&#x000a;&#x000a;&#x000a;&#x0009;&#x0009;The spec does not explicitly say that a loop&apos;s merge block and continue target &#x000a;&#x0009;&#x0009;have to be different. &#x000a;&#x000a;&#x0009;&#x0009;However, it says: &quot;a continue construct: includes the blocks dominated by an &#x000a;&#x0009;&#x0009;OpLoopMerge Continue Target and post dominated by the corresponding loop&#x2019;s &#x000a;&#x0009;&#x0009;back-edge block, while excluding blocks dominated by that loop&#x2019;s merge block&quot;&#x000a;&#x0009;&#x0009;&#x000a;&#x0009;&#x0009;This implies that if the loop&apos;s merge block and continue target were the same block, &#x000a;&#x0009;&#x0009;the loop&apos;s continue construct would be empty.&#x000a;&#x000a;&#x0009;&#x0009;Because the spec goes on to say: &quot;a continue construct must include its loop&#x2019;s back-edge block&quot;, &#x000a;&#x0009;&#x0009;this implies that a continue construct cannot be empty, which means that a loop&apos;s merge block &#x000a;&#x0009;&#x0009;and continue target have to be different.&#x000a; */&#x000a;fact  &#x000a;{&#x000a;&#x0009;all l : LoopHeader &amp; StructurallyReachableBlock | no l.merge &amp; l.continue&#x000a;}&#x000a;&#x000a;&#x000a;fact&#x000a;{&#x000a;&#x0009;no EntryBlock.~branchSet&#x000a;}&#x000a;&#x000a;&#x000a;fact &#x000a;{&#x000a;&#x0009;HeaderBlock = LoopHeader + SelectionHeader&#x000a;}&#x000a;&#x000a;&#x000a;/** weakly connected (loose ends), i.e., there is a path between every &quot;wholly unreachable&quot; block &#x000a;  * b1 and some structurally-reachable block b2 in the underlying undirected graph&#x000a;  */&#x000a;pred WeaklyConnected&#x000a;{&#x000a;&#x0009;all b1: StructurallyUnreachableBlock | some b2:  StructurallyReachableBlock  | b1 in b2.*(branchSet + ~branchSet)  &#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;..the merge block declared by a header block must not be a merge block&#x000a;  *   declared by any other header block&quot;&#x000a;  *   (The Khronos Group, 2021, p.29)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  */&#x000a;pred UniqueMergeBlock &#x000a;{&#x000a;&#x0009;all b : HeaderBlock &amp; StructurallyReachableBlock | no b.merge &amp; ((HeaderBlock &amp; StructurallyReachableBlock) - b).merge&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;..each header-block must strictly dominate its merge-block, unless the merge-block&#x000a;  *   is unreachable in the CFG&quot;&#x000a;  *   (The Khronos Group, 2021, p.29)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  */&#x000a;pred HeaderBlockStrictlyStructurallyDominatesItsMergeBlock &#x000a;{&#x000a;&#x0009;StructurallyReachableBlock &lt;: merge in strictlyStructurallyDominates&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;..all CFG back edges must branch to a loop header&quot;&#x000a;  *   (The Khronos Group, 2021, p.20)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  */&#x000a;pred  BackEdgesBranchToLoopHeader &#x000a;{&#x000a;&#x0009;ran[backEdge] &amp; StructurallyReachableBlock in LoopHeader &amp; StructurallyReachableBlock &#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;..each loop header has exactly one back edge branching to it&quot;&#x000a;  *   (The Khronos Group, 2021, p.29)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  */&#x000a;pred OneBackEdgeBranchingToLoopHeader &#x000a;{&#x000a;&#x0009;all lh :LoopHeader &amp; StructurallyReachableBlock  | one backEdgeSeq :&gt; lh&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;..the loop header must dominate the Continue Target,&#x000a;  *   unless the Continue Target is unreachable in the CFG&quot;&#x000a;  *   (The Khronos Group, 2021, p.29)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  */&#x000a;pred LoopHeaderStructurallyDominatesContinueTarget &#x000a;{&#x000a;&#x0009;StructurallyReachableBlock &lt;: continue in structurallyDominates&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;..the Continue Target must dominate the back-edge block&quot;&#x000a;  *   (The Khronos Group, 2021, p.29)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  */&#x000a;pred ContinueTargetStructurallyDominatesBackEdge &#x000a;{&#x000a;&#x0009;(~continue.~backEdge) :&gt; StructurallyReachableBlock in structurallyDominates&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;..the back-edge block must post dominate the Continue Target&quot;&#x000a;  *   (The Khronos Group, 2021, p.29)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  */&#x000a;pred BackEdgeStructurallyPostDominatesContinueTarget &#x000a;{&#x000a;&#x0009;StructurallyReachableBlock &lt;: (backEdge.continue) in structurallyPostDominates&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;...if a construct contains another header block, it also contains that header&#x2019;s corresponding&#x000a;&#x0009;&#x0009;merge block if that merge block is reachable in the CFG&quot;&#x000a;  *   (The Khronos Group, 2021, p.29)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  */&#x000a;pred ConstructContainsAnotherHeader &#x000a;{&#x000a;&#x0009;all disj h1,h2: (HeaderBlock &amp; StructurallyReachableBlock) | let lc  = loopConstruct[h1],&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; ctc = continueConstruct[h1.continue],&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; sc  = selectionConstruct[h1],&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; csc = caseConstruct[h1.branchSet - h1.merge]&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; |&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;   (h1 in LoopHeader &#x0009;  and h2 in lc  =&gt; h2.merge in lc )  and&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; &#x0009;&#x0009;&#x0009;(h1 in LoopHeader &#x0009;  and h2 in ctc =&gt; h2.merge in ctc)  and&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; &#x0009;&#x0009;&#x0009;(h1 in SelectionHeader and h2 in sc&#x0009; =&gt; h2.merge in sc )  and&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; &#x0009;&#x0009;&#x0009;(h1 in SwitchBlock &#x0009;  and h2 in csc =&gt; h2.merge in csc)&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;...a continue construct must include its loop&#x2019;s back-edge block&quot;&#x000a;  *   (The Khronos Group, 2021, p.29)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  *&#x000a;  *   This condition is redundant as it is implied by the other rules: see reasoning &#x000a;  *&#x0009;above about the fact that merge and continues for a loop must be different&#x000a;  */&#x000a;pred ContinueConstructIncludesItsBackEdge &#x000a;{&#x000a;&#x0009;all ct: LoopHeader.continue | some ct.~continue.~backEdge &amp; continueConstruct[ct]&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;...a break block is valid only for the innermost loop it is nested inside of&quot;&#x000a;  *   (The Khronos Group, 2021, p.29)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  */&#x000a;pred ValidBreakBlock &#x000a;{&#x000a;&#x0009;all br:  StructurallyReachableBlock  | let  lh = innermostLoop[br] | (some lh and some lh.~outerInnerLoop) =&gt; no  (br.branchSet.~merge) &amp; (lh.~outerInnerLoop)&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;...a continue block is valid only for the innermost loop it is nested inside of&quot;&#x000a;  *   (The Khronos Group, 2021, p.29)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  */&#x000a;pred ValidContinueBlock &#x000a;{&#x000a;&#x0009;all cb:  StructurallyReachableBlock   | let lh = innermostLoop[cb] | (some lh and some lh.~outerInnerLoop) =&gt; no (cb.branchSet.~continue) &amp; (lh.~outerInnerLoop)&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;...a branch to an outer OpSwitch merge block is:&#x000a;  *   valid only for the innermost OpSwitch the branch is nested inside of&quot;&#x000a;  *   (The Khronos Group, 2021, p.29)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  */&#x000a;pred ValidBranchToOuterOpSwitchMerge &#x000a;{&#x000a;&#x0009;all  b:  StructurallyReachableBlock , sw: SwitchBlock | let c = innermostOpSwitch[b] | (b in selectionConstruct[sw] and some c and sw != c) &#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;=&gt;   sw not in (b.branchSet.~merge &amp; (SwitchBlock - sw)).outerInnerSW&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;...a branch to an outer OpSwitch merge block is:&#x000a;  *   not valid if it is nested in a loop that is nested in that OpSwitch&quot;&#x000a;  *   (The Khronos Group, 2021, p.29)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  */&#x000a;pred InvalidBranchToOuterOpSwitchMerge &#x000a;{&#x000a;&#x0009;all b:  StructurallyReachableBlock , hInner: LoopHeader, sw: SwitchBlock  |  let l = loopConstruct[hInner] | (b in l and l in caseConstruct[sw.branchSet] )  =&gt;  sw not in ((b.branchSet.~merge &amp; (SwitchBlock -sw)).outerInnerSW)&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;...a branch from one case construct to another must be for the same OpSwitch&quot;&#x000a;  *   (The Khronos Group, 2021, p.29)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  */&#x000a;pred NobranchBetweenCaseConstructs &#x000a;{&#x000a;  all sw: (SwitchBlock &amp; StructurallyReachableBlock) | no  (caseConstruct[sw.branchSet] &lt;:branchSet:&gt; caseConstruct[(SwitchBlock - sw).branchSet]  )&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;...all branches into a construct from reachable blocks outside the construct&#x000a;  *   must be to the header block&quot;&#x000a;  *   (The Khronos Group, 2021, p.29)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  */&#x000a;pred BranchesBetweenConstructs &#x000a;{&#x000a;&#x0009;all  lh: LoopHeader &amp; StructurallyReachableBlock     &#x0009;&#x0009;   &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;      | let lc  = loopConstruct[lh], ctc = continueConstruct[lh.continue]&#x0009;| (some lc  =&gt; no ( StructurallyReachableBlock  - lc)  &lt;: branchSet :&gt; (lc - lh)) and  (some ctc =&gt; no ( StructurallyReachableBlock  - ctc) &lt;: branchSet :&gt; (ctc - lh.continue ))   &#x000a;&#x0009;all  sh: SelectionHeader &amp; StructurallyReachableBlock &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;         | let sc  = selectionConstruct[sh]  | some sc  =&gt; no ( StructurallyReachableBlock  - sc)  &lt;: branchSet :&gt; (sc - sh)&#x000a;&#x0009;all  sw_target : ((SwitchBlock.branchSet - SwitchBlock.merge) &amp; StructurallyReachableBlock)  | let csc = caseConstruct[sw_target]| some csc =&gt; no ( StructurallyReachableBlock  - csc) &lt;: branchSet :&gt; (csc - sw_target)&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;...an OpSwitch block dominates all its defined case constructs&quot;&#x000a;  *   (The Khronos Group, 2021, p.29)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  */&#x000a;pred OpSwitchBlockDominatesAllItsCases &#x000a;{&#x000a;&#x0009;all sw: (SwitchBlock &amp; StructurallyReachableBlock)  | (sw &lt;:branchSet:&gt; ( StructurallyReachableBlock  - sw.merge)) in structurallyDominates&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;...each case construct has at most one branch to another case construct&quot;&#x000a;  *   (The Khronos Group, 2021, p.29)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;*/&#x000a;pred AtMostOneBranchToAnotherCaseConstruct &#x000a;{&#x000a;&#x0009;all sw: (SwitchBlock &amp; StructurallyReachableBlock), from: sw.branchSet - sw.merge | let case_construct_from = caseConstruct[from] |&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;lone case_construct_from  &lt;:branchSet:&gt; (selectionConstruct[sw] - sw - case_construct_from)&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;...each case construct is branched to by at most one other case construct&quot;&#x000a;  *   (The Khronos Group, 2021, p.29)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  */&#x000a;pred CaseConstructBranchedToByAtMostOneOther &#x000a;{&#x000a;&#x0009;all sw: (SwitchBlock &amp; StructurallyReachableBlock), to: sw.branchSet - sw.merge | let case_construct_to = caseConstruct[to] |&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;lone (selectionConstruct[sw] - sw - case_construct_to) &lt;:branchSet:&gt; case_construct_to&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;...if Target T1 branches to Target T2, or if Target T1 branches to the Default&#x000a;  *  and the Default branches to Target T2, then T1 must immediately precede T2&#x000a;  *  in the list of the OpSwitch Target operands&quot;&#x000a;  *  (The Khronos Group, 2021, p.29)&#x000a;  *  https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  *&#x000a;  *&#x000a;  *  The above rule is adjusted as follows:&#x000a;  *&#x000a;  *  (a) if &apos;T1&apos; and &apos;T2&apos; appear as labels of targets in the **OpSwitch**&#x000a;  *      instruction and the case construct defined by &apos;T1&apos; branches to&#x000a;  *      the case construct defined by &apos;T2&apos; then the last target with label &apos;T1&apos; &#x000a;  *      must immediately precede the first target with label &apos;T2&apos; in the list of &#x000a;  *      *OpSwitch* &apos;Target&apos; operands&#x000a;  *&#x000a;  *  (b) if &apos;T1&apos; and &apos;T2&apos; appear as labels of targets in the **OpSwitch**&#x000a;  *      instruction and the case construct defined by &apos;T1&apos; branches to the&#x000a;  *      &apos;Default&apos; case construct of the **OpSwitch** which in turn&#x000a;  *      branches to the case construct defined by &apos;T2&apos;, then either:&#x000a;  *&#x000a;  *      (i)   the block that defines the &apos;Default&apos; case construct must&#x000a;  *            appear as a target label in the **OpSwitch** instruction, or&#x000a;  *      (ii)  the last target with label &apos;T1&apos; must immediately precede the&#x000a;  *            first target with label &apos;T2&apos; in the list of **OpSwitch**&#x000a;  *           &apos;Target&apos; operands&#x000a;  *&#x000a;  *  (c) for any label &apos;T&apos;, all targets with label &apos;T&apos; must appear consecutively &#x000a;  *      in the list of *OpSwitch* &apos;Target&apos; operands&#x000a;  *&#x000a;  */&#x000a;pred OrderOfOpSwitchTargetOperands &#x000a;{&#x000a;&#x0009;-- branch[0] is the default block&#x000a;&#x0009;all sw: (SwitchBlock &amp; StructurallyReachableBlock), &#x000a;&#x0009;&#x0009; disj T1,T2: sw.branch.rest.elems, &#x000a;&#x0009;&#x0009; t1: caseConstruct[T1], &#x000a;&#x0009;&#x0009; t2: caseConstruct[T2] &#x0009;&#x0009;|  let default = sw.branch.first, tail = sw.branch.rest |&#x000a; &#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;some t1 and some t2 and&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;( some t1 &lt;:branchSet:&gt; T2 ) ||&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;   (&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(some t1 &lt;:branchSet:&gt; default) and &#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; no  ((tail.elems)&amp;default)     and&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(some caseConstruct[default]&lt;:branchSet:&gt;T2)&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;)&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;)&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;)&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;=&gt;   ( idxOf [tail, T2] = lastIdxOf [tail, T1].add[1] )&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x000a;&#x0009;all sw: (SwitchBlock &amp; StructurallyReachableBlock), T: sw.branch.rest.elems | let tail = sw.branch.rest |&#x000a;  &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(tail.subseq [idxOf [tail, T], lastIdxOf [tail, T]]).elems = T // this checks whether the substring of occurrences of T is consecutive&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;The first block in a function definition is the entry point of that&#x000a;  *   function and must not be the target of any branch.&quot;&#x000a;  *   (The Khronos Group, 2021, p.35)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  *&#x000a;  *   This also implies that the entry point is not a LoopHeader because &#x000a;  *   otherwise it would be targeted by the back-edge&#x000a;  */&#x000a;pred EntryBlockIsNotTargeted&#x000a;{&#x000a;&#x0009;EntryBlock not in ran[branchSet]&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  &quot;OpLoopMerge must immediately precede either an OpBranch or OpBranchConditional&#x000a;  *   instruction. That is, it must be the second-to-last instruction in its block.&quot;&#x000a;  *   (The Khronos Group, 2021, p.210)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  */&#x000a;pred OpLoopMergeSecondToLast &#x000a;{&#x000a;&#x0009;{ all l: (LoopHeader &amp; StructurallyReachableBlock) | (one l&lt;:branch ) or (#(l&lt;:branch) = 2) }&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *   &quot;OpSelectionMerge must immediately precede either an OpBranchConditional or&#x000a;  * .  OpSwitch instruction. That is, it must be the second-to-last instruction in its block.&quot;&#x000a;  *   (The Khronos Group, 2021, p.211)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  */&#x000a;pred OpSelectionMergeSecondToLast &#x000a;{&#x000a;&#x0009;{ all s: ((SelectionHeader - SwitchBlock) &amp; StructurallyReachableBlock) | #(s&lt;:branch) = 2  }&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *   &quot;OpSwitch: Multi-way branch to one of the operand label &lt;id&gt;.&quot;&#x000a;  *   (The Khronos Group, 2021, p.212)&#x000a;  *   https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.pdf&#x000a;  *&#x000a;  *   Unconditional branchs have&#x00a0;at most two successors&#x000a;  *&#x000a;  */&#x000a;pred OutDegree &#x000a;{&#x000a;&#x0009;{all b: StructurallyReachableBlock  | b in SwitchBlock =&gt; some b&lt;:branch else #(b&lt;:branch) &lt;= 2}&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *   Restrict when multiple outgoing edges are allowed&#x000a;  *&#x000a;  *   A non-header block B can have 2 successors, C and D, if at least one of the edges B-&gt;C and B-&gt;D is an exit edge.&#x000a;  *&#x000a;  *   For header blocks we have already established the outdegrees&#x000a;  */&#x000a;pred MultipleOutEdges &#x000a;{&#x000a;&#x0009;all b: StructurallyReachableBlock - HeaderBlock | (#(b.branchSet) &gt;1)  =&gt; some b&lt;:exitEdge&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;     &#x000a;}&#x000a;&#x000a;&#x000a;pred ExitingTheConstruct&#x000a;{&#x000a;&#x0009;{all disj a,b:  StructurallyReachableBlock &#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; | let headOfInnermostConst_a = innermostConstructHeader[a], &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;   &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;   &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;   &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;   &#x0009; innermostConstruct_a &#x0009;= innermostConstr[a] &#x0009;&#x0009;,&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;   &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;   &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;   &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;   &#x0009; headOfInnermostConst_b = innermostConstructHeader[b], &#x0009;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; headOfInnermostLoop_a  = innermostLoop[a],&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; innermostLoopConst_a &#x0009;= loopConstruct[headOfInnermostLoop_a],&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; headOfInnermostSW_a    = innermostOpSwitch[a], &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; &#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; headOfinnermostContinueConst_a = innermostContinue[a],&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; innermostContinueConst_a &#x0009;= &#x0009;continueConstruct[headOfinnermostContinueConst_a]&#x0009; &#x0009;&#x0009;  &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;       | &#x000a;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;    &#x0009; (&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; b in a.branchSet &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;and &#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; some headOfInnermostConst_a&#x0009;&#x0009;and   --i.e., a is nested at some construct&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; b not in innermostConstruct_a &#x0009;and   --i.e., b is outside the innermost of a&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; (&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; some ((headOfInnermostConst_a.~branchSet &amp; headOfInnermostConst_b.~branchSet) &amp; SwitchBlock) //case-&gt;case&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; &#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;=&gt;&#x0009;a in innermostConstr[headOfInnermostConst_a &amp; (HeaderBlock + LoopHeader.continue)]  &#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; )&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;  )&#x000a;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;   =&gt; &#x000a;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;   &#x0009;&#x0009;&#x0009;(&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;-- Normal exit from a construct: &#x000a;&#x0009;&#x0009;    &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;(some a &lt;:branchSet:&gt; (headOfInnermostConst_a.merge &amp; b )  )   or&#x000a;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;-- ...for a continue construct, a normal exit implies that &apos;a&apos; is the back-edge block for the loop associated with the continue construct&#x000a;&#x0009;&#x0009;    &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; (headOfInnermostConst_a &#x0009; in LoopHeader.continue&#x0009;and some (a &amp; headOfInnermostConst_a.~continue.~backEdge) &lt;:branchSet:&gt; (headOfInnermostConst_a.~continue.merge &amp; b) )   or&#x000a;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;-- Branching from a back-edge block to a loop header:&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; (headOfInnermostConst_a in LoopHeader.continue&#x0009;and some (a &amp; headOfinnermostContinueConst_a.~continue.~backEdge) &lt;:branchSet:&gt; (headOfinnermostContinueConst_a.~continue &amp; b))&#x0009;or&#x000a;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;-- Branching to a loop merge from a non back-edge block: &#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; ( (no a &amp; LoopHeader.~backEdge) and (some headOfInnermostLoop_a &amp; LoopHeader)&#x0009;and (some innermostContinueConst_a =&gt; headOfInnermostLoop_a in innermostContinueConst_a) and  (some a &lt;:branchSet:&gt; (headOfInnermostLoop_a.merge &amp; b) )  )&#x0009;or&#x000a;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;-- Branching to a loop continue target from a non back-edge block: &#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; ( (no a &amp; LoopHeader.~backEdge) and (some headOfInnermostLoop_a &amp; LoopHeader)&#x0009;and (some innermostContinueConst_a =&gt; headOfInnermostLoop_a in innermostContinueConst_a) and  (some a &lt;:branchSet:&gt; (headOfInnermostLoop_a.continue &amp; b) )  ) or&#x000a;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;-- Branching to a switch merge: &#x0009;&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; (some headOfInnermostSW_a and (some innermostContinueConst_a =&gt; headOfInnermostSW_a in innermostContinueConst_a) and (some innermostLoopConst_a =&gt; headOfInnermostSW_a in innermostLoopConst_a)&#x0009;and  some a &lt;:branchSet:&gt; (headOfInnermostSW_a.merge &amp; b))   &#x000a;&#x0009;&#x0009;  &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;   &#x0009;)&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; &#x000a;&#x0009;}&#x000a;}&#x000a;&#x000a;&#x000a;pred StructurallyAcyclic &#x000a;{&#x000a;&#x0009;no ^(StructurallyReachableBlock &lt;: (branchSet + merge + continue - backEdge)) &amp; iden -- the result is structurally acyclic after removing self-loops and back edges&#x000a;}&#x000a;&#x000a;&#x000a;/**&#x000a;  *  Let B be a continue target; suppose that B is not a loop header and let A-&gt;B a control flow edge.&#x000a;  *  Then A is part of the loop associated with B. The rule also excludes consideration of backedges.&#x000a;  *&#x000a;  *  [The old version of spirv-val accepts edges like the ones in the following GitHub issue:&#x000a;  *   https://github.com/afd/spirv-control-flow/issues/28]&#x000a;  */&#x000a;pred BranchToContinue &#x000a;{&#x000a;&#x0009;{ all l: (LoopHeader &amp; StructurallyReachableBlock) | l != l.continue =&gt; no (StructurallyReachableBlock - loopConstruct[l]) &lt;: (branchSet - backEdge) :&gt; l.continue }&#x000a;}&#x000a;&#x000a;&#x000a;pred&#x0009; ex {}&#x000a;&#x000a;&#x000a;pred Valid { &#x000a;&#x000a;&#x0009;UniqueMergeBlock &#x000a;&#x0009;HeaderBlockStrictlyStructurallyDominatesItsMergeBlock &#x000a;&#x0009;BackEdgesBranchToLoopHeader &#x000a;&#x0009;OneBackEdgeBranchingToLoopHeader &#x000a;&#x0009;LoopHeaderStructurallyDominatesContinueTarget &#x000a;&#x0009;ContinueTargetStructurallyDominatesBackEdge &#x000a;&#x0009;BackEdgeStructurallyPostDominatesContinueTarget &#x000a;&#x0009;ConstructContainsAnotherHeader &#x000a;&#x0009;ValidBreakBlock &#x000a;&#x0009;ValidContinueBlock &#x000a;&#x0009;ValidBranchToOuterOpSwitchMerge &#x000a;&#x0009;InvalidBranchToOuterOpSwitchMerge &#x000a;&#x0009;NobranchBetweenCaseConstructs &#x000a;&#x0009;BranchesBetweenConstructs &#x000a;&#x0009;OpSwitchBlockDominatesAllItsCases &#x000a;&#x0009;AtMostOneBranchToAnotherCaseConstruct &#x000a;&#x0009;CaseConstructBranchedToByAtMostOneOther &#x000a;&#x0009;OrderOfOpSwitchTargetOperands&#x000a;&#x0009;EntryBlockIsNotTargeted &#x000a;&#x0009;OpLoopMergeSecondToLast &#x000a;&#x0009;OpSelectionMergeSecondToLast&#x000a;&#x0009;OutDegree &#x000a;&#x0009;MultipleOutEdges &#x000a;   ExitingTheConstruct &#x000a;&#x0009;StructurallyAcyclic&#x000a;   BranchToContinue&#x000a;}&#x000a;&#x000a;&#x000a;&#x000a;&#x000a;pred loop_example {&#x000a;/*&#x000a; * This control flow graph is invalid according to the SPIR-V Specification Version 1.5 wording &#x000a; * because the loop headed by b2 has no back edge: edge b4-&gt;b2 is not a back edge since b4 is unreachable.&#x000a; * In structural semantics, however, this example is deemed valid.&#x000a; */&#x000a;  some disj b1, b2, b3, b4 :  StructurallyReachableBlock  {&#x000a;    EntryBlock = b1&#x000a;    HeaderBlock = b2&#x000a;    LoopHeader = b2&#x000a;    SwitchBlock = none&#x000a;    branch = (b1 -&gt; (0 -&gt; b2))&#x000a;         + (b2 -&gt; (0 -&gt; b3))&#x000a;         + (b4 -&gt; (0 -&gt; b2))&#x000a;    merge = (b2 -&gt; b3)&#x000a;    continue = (b2 -&gt; b4)&#x000a;  }&#x000a;}&#x000a;--test1: run { loop_example &amp;&amp; Valid  } for 4 Block&#x000a;&#x000a;&#x000a;pred invalid_example {&#x000a;/* &#x000a; * Here the rule: &quot;ConstructContainsAnotherHeader: ..if a construct contains the header block of another construct, &#x000a; * it should also contain that construct&apos;s merge block&quot; is violated because b3 (which is a header) &#x000a; * is contained in the continue construct but b4 (the merge of b3) is not.&#x000a; */&#x000a;  some disj b1, b2, b3, b4, b5 :  StructurallyReachableBlock  {&#x000a;    EntryBlock = b1&#x000a;    HeaderBlock = b2 + b3&#x000a;    LoopHeader = b2&#x000a;    SwitchBlock = none&#x000a;    branch = (b1 -&gt; (0 -&gt; b2))&#x000a;         + (b2 -&gt; (0 -&gt; b3))&#x000a;         + (b3 -&gt; ((0 -&gt; b2) + (1 -&gt; b5)))&#x000a;         + (b4 -&gt; (0 -&gt; b5))&#x000a;    merge = (b2 -&gt; b5)&#x000a;         + (b3 -&gt; b4)&#x000a;    continue = (b2 -&gt; b3)&#x000a;  }&#x000a;}&#x000a;--test2: run { invalid_example &amp;&amp; Valid } for 5 Block&#x000a;&#x000a;pred Vibrant &#x000a;/*&#x000a; * There should not exist Blocks A, B, C, such that:&#x000a; * B is the only structural-successor of A&#x000a; * A is the only structural-predecessor of B&#x000a; * C is the only structural-successor of B&#x000a; * B is the only structural-predecessor of C&#x000a; */&#x000a;{&#x000a;&#x0009;all disj A,B,C: Block | not (  #(A. (branchSet + merge + continue) - A) = 1 and B in A.(branchSet + merge + continue)  and &#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; #(B.~(branchSet + merge + continue) - B) = 1 and A in B.~(branchSet + merge + continue) and&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; #(B. (branchSet + merge + continue) - B) = 1 and C in B. (branchSet + merge + continue) and &#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; #(C.~(branchSet + merge + continue) - C) = 1 and B in C.~(branchSet + merge + continue) &#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;  )&#x000a;&#x0009;all sw: SwitchBlock | #(sw&lt;:branch) &lt;= 3&#x000a;&#x000a;&#x0009;all  a,b: Block | #(a&lt;:branch:&gt;b) &lt; 2&#x000a;}&#x000a;&#x000a;pred MoreInteresting&#x000a;{&#x000a;&#x0009;/* no 2 outmost constructs - we impose here a more nested setup&#x000a;&#x0009; * we also impose existence of at least one loop as Alloy is lazily avoiding them&#x000a;&#x0009; */&#x000a;&#x0009;all disj h1,h2: HeaderBlock | some (h1+h2).~outerInner&#x000a;&#x0009;#LoopHeader &gt; 0&#x000a;&#x0009;all l: LoopHeader | l not in l.continue.branchSet&#x000a;}&#x000a;&#x000a;-- these four commands will generate valid instances of the model&#x000a;run {  Valid &amp;&amp; Vibrant &amp;&amp; Block = StructurallyReachableBlock } for exactly 4 Block &#x000a;run {  Valid &amp;&amp; Vibrant &amp;&amp; MoreInteresting  &amp;&amp; Block = StructurallyReachableBlock } for exactly 8 Block &#x000a;run {  Valid &amp;&amp; Vibrant &amp;&amp; MoreInteresting  &amp;&amp; Block = StructurallyReachableBlock } for exactly 10 Block &#x000a;run {  Valid &amp;&amp; Vibrant &amp;&amp; MoreInteresting  &amp;&amp; Block = StructurallyReachableBlock } for exactly 12 Block &#x000a;run {  Valid &amp;&amp; Vibrant &amp;&amp; MoreInteresting  &amp;&amp; Block = StructurallyReachableBlock } for exactly 14 Block &#x000a;&#x000a;-- the following command will generate invalid instances of the model that violate one of the constraint&#x000a;run { UniqueMergeBlock &amp;&amp; HeaderBlockStrictlyStructurallyDominatesItsMergeBlock &amp;&amp; not BackEdgesBranchToLoopHeader &amp;&amp; OneBackEdgeBranchingToLoopHeader &amp;&amp; LoopHeaderStructurallyDominatesContinueTarget &amp;&amp; ContinueTargetStructurallyDominatesBackEdge &amp;&amp; BackEdgeStructurallyPostDominatesContinueTarget &amp;&amp; not ConstructContainsAnotherHeader &amp;&amp; ValidBreakBlock &amp;&amp; ValidContinueBlock &amp;&amp; ValidBranchToOuterOpSwitchMerge &amp;&amp; InvalidBranchToOuterOpSwitchMerge &amp;&amp; NobranchBetweenCaseConstructs &amp;&amp; BranchesBetweenConstructs &amp;&amp; OpSwitchBlockDominatesAllItsCases &amp;&amp; AtMostOneBranchToAnotherCaseConstruct &amp;&amp; CaseConstructBranchedToByAtMostOneOther &amp;&amp; OrderOfOpSwitchTargetOperands &amp;&amp; EntryBlockIsNotTargeted &amp;&amp; OpLoopMergeSecondToLast &amp;&amp; OpSelectionMergeSecondToLast &amp;&amp; OutDegree &amp;&amp; MultipleOutEdges &amp;&amp; ExitingTheConstruct &amp;&amp; StructurallyAcyclic &amp;&amp; BranchToContinue &amp;&amp;  Vibrant &amp;&amp; MoreInteresting &amp;&amp; Block = StructurallyReachableBlock  } for exactly 8 Block&#x000a;"/>

<source filename="/$alloy4$/models/util/integer.als" content="module util/integer&#x000a;&#x000a;/*&#x000a; * A collection of utility functions for using Integers in Alloy.&#x000a; * Note that integer overflows are silently truncated to the current bitwidth&#x000a; * using the 2&apos;s complement arithmetic, unless the &quot;forbid overfows&quot; option is&#x000a; * turned on, in which case only models that don&apos;t have any overflows are &#x000a; * analyzed. &#x000a; */&#x000a;&#x000a;fun add  [n1, n2: Int] : Int { this/plus[n1, n2] }&#x000a;fun plus [n1, n2: Int] : Int { n1 fun/add n2 }&#x000a;&#x000a;fun sub   [n1, n2: Int] : Int { this/minus[n1, n2] }&#x000a;fun minus [n1, n2: Int] : Int { n1 fun/sub n2 }&#x000a;&#x000a;fun mul [n1, n2: Int] : Int { n1 fun/mul n2 }&#x000a;&#x000a;/**&#x000a; * Performs the division with &quot;round to zero&quot; semantics, except the following 3 cases&#x000a; * 1) if a is 0, then it returns 0&#x000a; * 2) else if b is 0, then it returns 1 if a is negative and -1 if a is positive&#x000a; * 3) else if a is the smallest negative integer, and b is -1, then it returns a&#x000a; */&#x000a;fun div [n1, n2: Int] : Int { n1 fun/div n2 }&#x000a;&#x000a;/** answer is defined to be the unique integer that satisfies &quot;a = ((a/b)*b) + remainder&quot; */&#x000a;fun rem [n1, n2: Int] : Int { n1 fun/rem n2 }&#x000a;&#x000a;/** negate */&#x000a;fun negate [n: Int] : Int { 0 fun/sub n }&#x000a;&#x000a;/** equal to */&#x000a;pred eq [n1, n2: Int] { int[n1] = int[n2] }&#x000a;&#x000a;/** greater than */&#x000a;pred gt [n1, n2: Int] { n1 &gt; n2 }&#x000a;&#x000a;/** less then */&#x000a;pred lt [n1, n2: Int] { n1 &lt; n2 }&#x000a;&#x000a;/** greater than or equal */&#x000a;pred gte [n1, n2: Int] { n1 &gt;= n2 }&#x000a;&#x000a;/** less than or equal */&#x000a;pred lte [n1, n2: Int] { n1 &lt;= n2 }&#x000a;&#x000a;/** integer is zero */&#x000a;pred zero [n: Int] { n = 0 }&#x000a;&#x000a;/** positive */&#x000a;pred pos  [n: Int] { n &gt; 0 }&#x000a;&#x000a;/** negative */&#x000a;pred neg  [n: Int] { n &lt; 0 }&#x000a;&#x000a;/** non-positive */&#x000a;pred nonpos [n: Int] { n &lt;= 0 }&#x000a;&#x000a;/** non-negative */&#x000a;pred nonneg [n: Int] { n &gt;= 0 }&#x000a;&#x000a;/** signum (aka sign or sgn) */&#x000a;fun signum [n: Int] : Int { n&lt;0 =&gt; (0 fun/sub 1) else (n&gt;0 =&gt; 1 else 0) }&#x000a;&#x000a;/**&#x000a; * returns the ith element (zero-based) from the set s&#x000a; * in the ordering of &apos;next&apos;, which is a linear ordering&#x000a; * relation like that provided by util/ordering&#x000a; */&#x000a;fun int2elem[i: Int, next: univ-&gt;univ, s: set univ] : lone s {&#x000a;  {e: s | #^next.e = int i }&#x000a;}&#x000a;&#x000a;/**&#x000a; * returns the index of the element (zero-based) in the&#x000a; * ordering of next, which is a linear ordering relation&#x000a; * like that provided by util/ordering&#x000a; */&#x000a;fun elem2int[e: univ, next: univ-&gt;univ] : lone Int {&#x000a;  Int[#^next.e]&#x000a;}&#x000a;&#x000a;/** returns the largest integer in the current bitwidth */&#x000a;fun max:one Int { fun/max }&#x000a;&#x000a;/** returns the smallest integer in the current bitwidth */&#x000a;fun min:one Int { fun/min }&#x000a;&#x000a;/** maps each integer (except max) to the integer after it */&#x000a;fun next:Int-&gt;Int { fun/next }&#x000a;&#x000a;/** maps each integer (except min) to the integer before it */&#x000a;fun prev:Int-&gt;Int { ~next }&#x000a;&#x000a;/** given a set of integers, return the largest element */&#x000a;fun max [es: set Int]: lone Int { es - es.^prev }&#x000a;&#x000a;/** given a set of integers, return the smallest element */&#x000a;fun min [es: set Int]: lone Int { es - es.^next }&#x000a;&#x000a;/** given an integer, return all integers prior to it */&#x000a;fun prevs [e: Int]: set Int { e.^prev }&#x000a;&#x000a;/** given an integer, return all integers following it */&#x000a;fun nexts [e: Int]: set Int { e.^next }&#x000a;&#x000a;/** returns the larger of the two integers */&#x000a;fun larger [e1, e2: Int]: Int { let a=int[e1], b=int[e2] | (a&lt;b =&gt; b else a) }&#x000a;&#x000a;/** returns the smaller of the two integers */&#x000a;fun smaller [e1, e2: Int]: Int { let a=int[e1], b=int[e2] | (a&lt;b =&gt; a else b) }&#x000a;"/>

<source filename="/$alloy4$/models/util/relation.als" content="module util/relation&#x000a;&#x000a;/*&#x000a; * Utilities for some common operations and constraints&#x000a; * on binary relations. The keyword &apos;univ&apos; represents the&#x000a; * top-level type, which all other types implicitly extend.&#x000a; * Therefore, all the functions and predicates in this model&#x000a; * may be applied to binary relations of any type.&#x000a; *&#x000a; * author: Greg Dennis&#x000a; */&#x000a;&#x000a;/** returns the domain of a binary relation */&#x000a;fun dom [r: univ-&gt;univ] : set (r.univ) { r.univ }&#x000a;&#x000a;/** returns the range of a binary relation */&#x000a;fun ran [r: univ-&gt;univ] : set (univ.r) { univ.r }&#x000a;&#x000a;/** r is total over the domain s */&#x000a;pred total [r: univ-&gt;univ, s: set univ] {&#x000a;  all x: s | some x.r&#x000a;}&#x000a;&#x000a;/** r is a partial function over the domain s */&#x000a;pred functional [r: univ-&gt;univ, s: set univ] {&#x000a;  all x: s | lone x.r&#x000a;}&#x000a;&#x000a;/** r is a total function over the domain s */&#x000a;pred function [r: univ-&gt;univ, s: set univ] {&#x000a;  all x: s | one x.r&#x000a;}&#x000a;&#x000a;/** r is surjective over the codomain s */&#x000a;pred surjective [r: univ-&gt;univ, s: set univ] {&#x000a;  all x: s | some r.x&#x000a;}&#x000a;&#x000a;/** r is injective */&#x000a;pred injective [r: univ-&gt;univ, s: set univ] {&#x000a;  all x: s | lone r.x&#x000a;}&#x000a;&#x000a;/** r is bijective over the codomain s */&#x000a;pred bijective[r: univ-&gt;univ, s: set univ] {&#x000a;  all x: s | one r.x&#x000a;}&#x000a;&#x000a;/** r is a bijection over the domain d and the codomain c */&#x000a;pred bijection[r: univ-&gt;univ, d, c: set univ] {&#x000a;  function[r, d] &amp;&amp; bijective[r, c]&#x000a;}&#x000a;&#x000a;/** r is reflexive over the set s */&#x000a;pred reflexive [r: univ -&gt; univ, s: set univ] {s&lt;:iden in r}&#x000a;&#x000a;/** r is irreflexive */&#x000a;pred irreflexive [r: univ -&gt; univ] {no iden &amp; r}&#x000a;&#x000a;/** r is symmetric */&#x000a;pred symmetric [r: univ -&gt; univ] {~r in r}&#x000a;&#x000a;/** r is anti-symmetric */&#x000a;pred antisymmetric [r: univ -&gt; univ] {~r &amp; r in iden}&#x000a;&#x000a;/** r is transitive */&#x000a;pred transitive [r: univ -&gt; univ] {r.r in r}&#x000a;&#x000a;/** r is acyclic over the set s */&#x000a;pred acyclic[r: univ-&gt;univ, s: set univ] {&#x000a;  all x: s | x !in x.^r&#x000a;}&#x000a;&#x000a;/** r is complete over the set s */&#x000a;pred complete[r: univ-&gt;univ, s: univ] {&#x000a;  all x,y:s | (x!=y =&gt; x-&gt;y in (r + ~r))&#x000a;}&#x000a;&#x000a;/** r is a preorder (or a quasi-order) over the set s */&#x000a;pred preorder [r: univ -&gt; univ, s: set univ] {&#x000a;  reflexive[r, s]&#x000a;  transitive[r]&#x000a;}&#x000a;&#x000a;/** r is an equivalence relation over the set s */&#x000a;pred equivalence [r: univ-&gt;univ, s: set univ] {&#x000a;  preorder[r, s]&#x000a;  symmetric[r]&#x000a;}&#x000a;&#x000a;/** r is a partial order over the set s */&#x000a;pred partialOrder [r: univ -&gt; univ, s: set univ] {&#x000a;  preorder[r, s]&#x000a;  antisymmetric[r]&#x000a;}&#x000a;&#x000a;/** r is a total order over the set s */&#x000a;pred totalOrder [r: univ -&gt; univ, s: set univ] {&#x000a;  partialOrder[r, s]&#x000a;  complete[r, s]&#x000a;}&#x000a;"/>

<source filename="/$alloy4$/models/util/sequniv.als" content="module util/sequniv&#x000a;&#x000a;open util/integer as ui&#x000a;&#x000a;/*&#x000a; * NOTE: Do not include this module manually.&#x000a; * Instead, use the &quot;seq&quot; keyword which will automatically&#x000a; * import this module with the correct additional constraints as needed.&#x000a; */&#x000a;&#x000a;/*&#x000a; * A sequence utility for modeling sequences as just a&#x000a; * relation as opposed to reifying them into sequence&#x000a; * atoms like the util/sequence module does.&#x000a; *&#x000a; * Precondition: each input sequence must range over a prefix&#x000a; * of seq/Int.&#x000a; *&#x000a; * Postcondition: we guarantee the returned sequence&#x000a; * also ranges over a prefix of seq/Int.&#x000a; *&#x000a; * @author Greg Dennis&#x000a; */&#x000a;&#x000a;/** sequence covers a prefix of seq/Int */&#x000a;pred isSeq[s: Int -&gt; univ] {&#x000a;  s in seq/Int -&gt; lone univ&#x000a;  s.inds - ui/next[s.inds] in 0&#x000a;}&#x000a;&#x000a;/** returns all the elements in this sequence */&#x000a;fun elems [s: Int -&gt; univ]: set (Int.s) { seq/Int . s }&#x000a;&#x000a;/**&#x000a; * returns the first element in the sequence&#x000a; * (Returns the empty set if the sequence is empty)&#x000a; */&#x000a;fun first [s: Int -&gt; univ]: lone (Int.s) { s[0] }&#x000a;&#x000a;/**&#x000a; * returns the last element in the sequence&#x000a; * (Returns the empty set if the sequence is empty)&#x000a; */&#x000a;fun last [s: Int -&gt; univ]: lone (Int.s) { s[lastIdx[s]] }&#x000a;&#x000a;/**&#x000a; * returns the cdr of the sequence&#x000a; * (Returns the empty sequence if the sequence has 1 or fewer element)&#x000a; */&#x000a;fun rest [s: Int -&gt; univ] : s { seq/Int &lt;: ((ui/next).s) }&#x000a;&#x000a;/** returns all but the last element of the sequence */&#x000a;fun butlast [s: Int -&gt; univ] : s {&#x000a;  (seq/Int - lastIdx[s]) &lt;: s&#x000a;}&#x000a;&#x000a;/** true if the sequence is empty */&#x000a;pred isEmpty [s: Int -&gt; univ] { no s }&#x000a;&#x000a;/** true if this sequence has duplicates */&#x000a;pred hasDups [s: Int -&gt; univ] { # elems[s] &lt; # inds[s] }&#x000a;&#x000a;/** returns all the indices occupied by this sequence */&#x000a;fun inds [s: Int -&gt; univ]: set Int { s.univ }&#x000a;&#x000a;/**&#x000a; * returns last index occupied by this sequence&#x000a; * (Returns the empty set if the sequence is empty)&#x000a; */&#x000a;fun lastIdx [s: Int -&gt; univ]: lone Int { ui/max[inds[s]] }&#x000a;&#x000a;/**&#x000a; * returns the index after the last index&#x000a; * if this sequence is empty, returns 0&#x000a; * if this sequence is full, returns empty set&#x000a; */&#x000a;fun afterLastIdx [s: Int -&gt; univ] : lone Int { ui/min[seq/Int - inds[s]] }&#x000a;&#x000a;/** returns first index at which given element appears or the empty set if it doesn&apos;t */&#x000a;fun idxOf [s: Int -&gt; univ, e: univ] : lone Int { ui/min[indsOf[s, e]] }&#x000a;&#x000a;/** returns last index at which given element appears or the empty set if it doesn&apos;t */&#x000a;fun lastIdxOf [s: Int -&gt; univ, e: univ] : lone Int { ui/max[indsOf[s, e]] }&#x000a;&#x000a;/** returns set of indices at which given element appears or the empty set if it doesn&apos;t */&#x000a;fun indsOf [s: Int -&gt; univ, e: univ] : set Int { s.e }&#x000a;&#x000a;/**&#x000a; * return the result of appending e to the end of s&#x000a; * (returns s if s exhausted seq/Int)&#x000a; */&#x000a;fun add [s: Int -&gt; univ, e: univ] : s + (seq/Int-&gt;e) {&#x000a;  setAt[s, afterLastIdx[s], e]&#x000a;}&#x000a;&#x000a;/**&#x000a; * returns the result of setting the value at index i in sequence to e&#x000a; * Precondition: 0 &lt;= i &lt; #s&#x000a; */&#x000a;fun setAt [s: Int -&gt; univ, i: Int, e: univ] : s + (seq/Int-&gt;e) {&#x000a;  s ++ i -&gt; e&#x000a;}&#x000a;&#x000a;/**&#x000a; * returns the result of inserting value e at index i&#x000a; * (if sequence was full, the original last element will be removed first)&#x000a; * Precondition: 0 &lt;= i &lt;= #s&#x000a; */&#x000a;fun insert [s: Int -&gt; univ, i: Int, e: univ] : s + (seq/Int-&gt;e) {&#x000a;  seq/Int &lt;: ((ui/prevs[i] &lt;: s) + (i-&gt;e) + ui/prev.((ui/nexts[i] + i) &lt;: s))&#x000a;}&#x000a;&#x000a;/**&#x000a; * returns the result of deleting the value at index i&#x000a; * Precondition: 0 &lt;= i &lt; #s&#x000a; */&#x000a;fun delete[s: Int -&gt; univ, i: Int] : s {&#x000a;  (ui/prevs[i] &lt;: s) + (ui/next).(ui/nexts[i] &lt;: s)&#x000a;}&#x000a;&#x000a;/**&#x000a; * appended is the result of appending s2 to s1&#x000a; * (If the resulting sequence is too long, it will be truncated)&#x000a; */&#x000a;fun append [s1, s2: Int -&gt; univ] : s1+s2 {&#x000a;  let shift = {i&apos;, i: seq/Int | int[i&apos;] = ui/add[int[i], ui/add[int[lastIdx[s1]], 1]] } |&#x000a;    no s1 =&gt; s2 else (s1 + shift.s2)&#x000a;}&#x000a;&#x000a;/**&#x000a; * returns the subsequence of s between from and to, inclusive&#x000a; * Precondition: 0 &lt;= from &lt;= to &lt; #s&#x000a; */&#x000a;fun subseq [s: Int -&gt; univ, from, to: Int] : s {&#x000a;  let shift = {i&apos;, i: seq/Int | int[i&apos;] = ui/sub[int[i], int[from]] } |&#x000a;    shift.((seq/Int - ui/nexts[to]) &lt;: s)&#x000a;}&#x000a;"/>

</alloy>
